//
//  BCAVRLinkerSpecification.m
//  AVRCompilerPlugin
//
//  Created by Jeremy Knope on 1/9/11.
//  Copyright 2011 Ambrosia Software, Inc. All rights reserved.
//

#import "BCAVRLinkerSpecification.h"
#import "XCPBuildSystem.h"
#import "XCPDependencyGraph.h"
#import "XCPSupport.h"

@implementation BCAVRLinkerSpecification

// TODO: these methods don't seem to be called at all

- (NSArray*)createCommandsInBuildContext:(PBXTargetBuildContext*)context
{
    // this method must be override since Xcode 3.0 : the default implementation doesn't call
    // computeDependenciesForFilePaths: anymore
    NSArray* inputs = [[context expandedValueForString:@"$(Inputs)"] arrayByParsingAsStringList];
    NSString* output = [context expandedValueForString:@"$(Output)"];
    return [self computeDependenciesForFilePaths:inputs outputPath:output inTargetBuildContext:context];
}

- (NSArray*)computeDependenciesForFilePaths:(NSArray*)inputs
								 outputPath:(NSString*)output
					   inTargetBuildContext:(PBXTargetBuildContext*)context
{
    // compute output path (for variable substitution)
    output = [context expandedValueForString:output];
    
    // create linker command
    XCDependencyNode* outputNode = [context dependencyNodeForName:output createIfNeeded:YES];
    XCDependencyCommand* dep = [context
								createCommandWithRuleInfo:[NSArray arrayWithObjects:@"avr-gcc",[context naturalPathForPath:output],nil]
								commandPath:[context expandedValueForString:[self path]]
								arguments:nil
								forNode:outputNode];
    [dep setToolSpecification:self];
    [dep addArgumentsFromArray:[self commandLineForAutogeneratedOptionsInTargetBuildContext:context]];
	[dep addArgumentsFromArray:[[context expandedValueForString:@"$(OTHER_LDFLAGS)"] arrayByParsingAsStringList]];
    [dep addArgument:@"-o"];
    [dep addArgument:output];
	NSLog(@"Adding arguments: %@", [context expandedValueForString:@"$(OTHER_LDFLAGS)"]);
    
    // some types
//    PBXFileType* myObjectFileType = (PBXFileType*)[PBXFileType specificationForIdentifier:@"compiled.myobjfile"];
//    PBXFileType* myLibraryFileType = (PBXFileType*)[PBXFileType specificationForIdentifier:@"compiled.mylibraryfile"];
    
    // create dependency rules & command arguments for libraries
    NSEnumerator* libraryEnum = [[context linkedLibraryPaths] objectEnumerator];
    NSString* library;
    while((library = [libraryEnum nextObject]) != nil) {
        library = [context expandedValueForString:library];
//        PBXFileType* type = [PBXFileType fileTypeForFileName:[library lastPathComponent]];
        
        //if([type isKindOfSpecification:myLibraryFileType] || [type isKindOfSpecification:myObjectFileType]) {
            XCDependencyNode* libraryNode = [context dependencyNodeForName:library createIfNeeded:YES];
            [outputNode addDependedNode:libraryNode];
            [dep addArgument:library];
            
//        } else {
//            [context addDependencyAnalysisWarningMessageFormat:
//			 @"warning: skipping file '%@' (unexpected file type '%@' in Frameworks & Libraries build phase)",
//			 library, [type identifier]];
//        }
    }
    
    // create dependency rules & command arguments for compiled object
    NSEnumerator* objectEnum = [inputs objectEnumerator];
    NSString* input;
    while((input = [objectEnum nextObject]) != nil) {
        input = [context expandedValueForString:input];
//        PBXFileType* type = [PBXFileType fileTypeForFileName:[input lastPathComponent]];
        
//        if([type isKindOfSpecification:myObjectFileType]) {
            XCDependencyNode* inputNode = [context dependencyNodeForName:input createIfNeeded:YES];
            [outputNode addDependedNode:inputNode];
            [dep addArgument:input];
            
//        } else {
//            [context addDependencyAnalysisWarningMessageFormat:
//			 @"warning: skipping file '%@' (unexpected file type '%@' in link phase)",
//			 input, [type identifier]];
//        }
    }
    
    return [NSArray arrayWithObject:outputNode];
}

@end
